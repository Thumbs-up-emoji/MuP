Rotate and shift are two types of bitwise operations that can be performed on binary data in assembly language. They are used to manipulate the bits in a register or memory location by moving them to the left or right by a specified number of positions. The difference between rotate and shift is that rotate preserves all the bits, while shift discards some bits and fills the empty spaces with zeros or the sign bit.

For example, suppose we have a byte of data 1010 1100 in the AL register. If we apply a rotate left instruction ROL AL, 1, we get 0101 1001 in the AL register and 1 in the carry flag. The leftmost bit 1 is moved to the rightmost position and also copied to the carry flag. If we apply a shift left instruction SHL AL, 1, we get 0101 1000 in the AL register and 1 in the carry flag. The leftmost bit 1 is moved to the carry flag and the rightmost position is filled with 0.

There are four types of rotate instructions: ROL, ROR, RCL, and RCR. ROL and ROR are logical rotates, which do not affect the sign of the data. RCL and RCR are rotate with carry, which use the carry flag as an extra bit to store the shifted bit. There are four types of shift instructions: SHL, SHR, SAL, and SAR. SHL and SHR are logical shifts, which fill the empty spaces with zeros. SAL and SAR are arithmetic shifts, which fill the empty spaces with the sign bit to preserve the sign of the data.

q1. count 1s in binary representation
    mov ax, num ; load the number into ax
    mov bx, 0   ; initialize the counter to 0

count_ones:
    mov cx, ax  ; copy the number into cx
    and cx, 1   ; bitwise AND with 1 to check the last bit
    cmp cx, 0   ; compare the result with 0
    jne increment ; if the result is not zero, jump to increment
    jmp rotate  ; if the result is zero, jump to rotate

increment:
    add bx, 1   ; increment the counter
    jmp rotate  ; jump to rotate

rotate:
    rol ax, 1   ; rotate the number to the left by 1 bit
    cmp ax, num ; compare the number with the original number
    jne count_ones ; if the number is not the original number, jump to count_ones

; memory location 100: code to execute after counting the ones
    jmp 200     ; jump to memory location 200 (end of the program)

; memory location 200: end of the program

q2.check if divisible by 32
    mov ax, num ; load the number into ax
    mov bx, 31  ; load 31 into bx to mask the last 5 bits
    and ax, bx  ; mask the last 5 bits of the number
    cmp ax, 0   ; compare the result with 0
    jne 200     ; if the result is not zero, jump to memory location 200

; memory location 100: code to execute if the number is divisible by 32
    jmp 300     ; jump to memory location 300 (end of the program)

; memory location 200: code to execute if the number is not divisible by 32

; memory location 300: end of the program

q3.check if 2 words are anagrams
section .data
    ; memory locations for the character counts
    count1 db 256 dup(0)
    count2 db 256 dup(0)

section .text
    ; assume file1 and file2 are already opened and their file handles are in bx and cx respectively

    ; read and count the characters in the first file
read1:
    ; assume the character is read into al
    inc byte [count1 + ax]
    ; repeat for all characters in file1

    ; read and count the characters in the second file
read2:
    ; assume the character is read into al
    inc byte [count2 + ax]
    ; repeat for all characters in file2

    ; compare the character counts
    mov cx, 256
    mov si, count1
    mov di, count2
compare:
    mov al, [si]
    cmp al, [di]
    jne not_anagrams
    inc si
    inc di
    dec cx
    jnz compare

    ; if we get here, the words are anagrams
    ; return with zero flag set
    xor ax, ax
    ret

not_anagrams:
    ; if we get here, the words are not anagrams
    ; return with zero flag cleared
    mov ax, 1
    ret